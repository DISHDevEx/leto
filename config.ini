[DEFAULT]
input_bucket_s3 = leto-dish
output_bucket_s3 = leto-dish
model_bucket_s3 = leto-dish ; s3 bucket of the pre-trained model
region = us-east-1

; REDUCTION (R1) METHODS:

[reduction.fps_bitrate]
; method specific parameters:
fps = 20 ; set the desired fps (frames per second)
bitrate = 100 ; Sets the bitrate of the video in KB/s. If bitrate is set as 0, then the framework will do a 10x bitrate reduction.

; s3 prefixs for input/output:
method_name = fps_bitrate
input_prefix_s3 = original-videos/
output_prefix_s3 = reduced-videos/${method_name}-fps_${fps}-bitrate_${bitrate}/


[reduction.ffmpeg_resolution_downsampler]
; method specific paramgers:
quality = 360p ; Can use: 240p, 360p,480p,720p,1080p as inputs
algorithm = lanczos ; Refer https://ffmpeg.org/ffmpeg-scaler.html to see the ffmpeg scaler algorithms

; s3 prefixs for input/output
method_name = ffmpeg_rd
input_prefix_s3 = original-videos/
output_prefix_s3 = reduced-videos/${method_name}-quality_${quality}-algorithm_${algorithm}/


[reduction.cv2_jpg_reduction]
; method specific paramgers:
temp_path = temp ; A temp folder to store video from uploading to s3
quality = 15 ; The compression rate for cv2 to apply, 100 is for best video quality, 0 is for the worse video quality
crf = 28 ; the constant rate factor for ffmpeg to encode the video, the lower value results in higher quality. The range is 0-51

; s3 prefixs for input/output
method_name = cv2_jpg
input_prefix_s3 = original-videos/
output_prefix_s3 = reduced-videos/${method_name}-quality_${quality}-crf_${crf}/

; RECONSTRUCTION (R2) METHODS:

[reconstruction.fastsrgan]
; method specific parameters:
codec = mp4v ; desired video codec

; cloud_functionality parameters:
download_model = True ; boolean to indicate if a model needs to be downloaded
local_model_path = fastsrgan.h5 ; local path to save pre-trained model
clean_model = True ; boolean to indicate to clean video or not  input video

; s3 prefixs for input/output paths and models:
method_name = fastsrgan
input_prefix_s3 = reduced-videos/${reduction.ffmpeg_resolution_downsampler:method_name}-quality_${reduction.ffmpeg_resolution_downsampler:quality}-algorithm_${reduction.ffmpeg_resolution_downsampler:algorithm}/
output_prefix_s3 = reconstructed-videos/${method_name}-codec_${codec}/
model_prefix_s3 = pretrained-models/fastsrgan.h5 ; s3 prefix of the pre-trained model


[reconstruction.opencv_ru]
; method specific parameters:
codec = mp4v ; desired video codec

; desired video resolution
height = 1080
width = 1920

; s3 prefixs for input/output paths and models:
method_name = opencv_ru
input_prefix_s3 = reduced-videos/${reduction.ffmpeg_resolution_downsampler:method_name}-quality_${reduction.ffmpeg_resolution_downsampler:quality}-algorithm_${reduction.ffmpeg_resolution_downsampler:algorithm}/
output_prefix_s3 = reconstructed-videos/${method_name}-codec_${codec}-resolution_${height}X${width}/


[reconstruction.realbasicvsr]
; method specific parameters:
codec = mp4v ; desired video codec

; cloud_functionality parameters:
download_model = True ; boolean to indicate if a model needs to be downloaded
local_model_path = realbasicvsr_x4.pth ; local path to save pre-trained model
clean_model = True ; boolean to indicate to clean video or not

; s3 prefixs for input/output paths and models:
method_name = realbasicvsr
input_prefix_s3 = reduced-videos/${reduction.ffmpeg_resolution_downsampler:method_name}-quality_${reduction.ffmpeg_resolution_downsampler:quality}-algorithm_${reduction.ffmpeg_resolution_downsampler:algorithm}/
output_prefix_s3 = reconstructed-videos/${method_name}-codec_${codec}/
model_prefix_s3 = pretrained-models/realbasicvsr_x4.pth ; s3 prefix of the pre-trained model


[reconstruction.superres]
; method specific parameters:
codec = mp4v ; desired video codec

; cloud_functionality parameters:
download_model = True ; boolean to indicate if a model needs to be downloaded
local_model_path = fsrcnn_x4.pb ; local path to save pre-trained model
clean_model = True ; boolean to indicate to clean video or not

; s3 prefixs for input/output paths and models:
method_name = superres
input_prefix_s3 = reduced-videos/${reduction.ffmpeg_resolution_downsampler:method_name}-quality_${reduction.ffmpeg_resolution_downsampler:quality}-algorithm_${reduction.ffmpeg_resolution_downsampler:algorithm}/
output_prefix_s3 = reconstructed-videos/${method_name}-codec_${codec}/
model_prefix_s3 = pretrained-models/fsrcnn_x4.pb ; s3 prefix of the pre-trained model


; VIDEO BENCHMARKING:

[benchmarking.original_file_size]
; method specific arguments
table_name = leto_test
directory_key = original-videos/


[benchmarking.reduced_file_size]
; method specific arguments
table_name = leto_reduced_file_sizes
directory_key = original-videos/


[benchmarking.reconstructed_file_size]
; method specific arguments
table_name = leto_reconstructed_file_size
directory_key = reduced-videos/ffmpeg-resolution-downsampler-480p-lanczos/


[benchmarking.mp_confidence]
; method specific arguments
function_name = leto-mediapipie
folder_path = original-videos/
dynamodb_table = leto-test-yolo
invocation_type = RequestResponse ; Use 'Event' for asynchronous invocation


[benchmarking.yolo_confidence]
function_name = your_lambda_function_name
folder_path = original-videos/
dynamodb_table = leto-yolo
invocation_type = RequestResponse ; Use 'Event' for asynchronous invocation
